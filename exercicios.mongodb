/* 1- Ajude a Trybe a escolher um filme para a próxima noite! Baseado em
uma pesquisa, decidimos que os filmes em potencial devem atender
alguns critérios, vejamos */
db.movies.aggregate([
  {
    $match: {
      "imdb.rating": { $gte: 7 },
      genres: { $nin: ["Crime", "Horror"] },
      rated: { $in: ["PG", "G"] },
      languages: { $all: ["English", "Spanish"] },
    },
  },
]);

/* 2- A escolha do filme da noite foi um sucesso, mas
infelizmente ficamos com nossa banda de internet quase
esgotada, e ainda precisamos de uma nova recomendação de
filme. Para diminuir o volume de dados trafegados: */
db.movies.aggregate([
  {
    $match: {
      "imdb.rating": { $gte: 7 },
      genres: { $nin: ["Crime", "Horror"] },
      rated: { $in: ["PG", "G"] },
      languages: { $all: ["English", "Spanish"] },
    },
  },
  {
    $project: {
      titulo: "$title",
      avaliado: "$rated",
      notaIMDB: "$imdb.rating",
      votosIMDB: "$imdb.votes",
      ano: "$year",
      _id: 0,
    },
  },
]);

/* 3- Agora que você tem os campos essenciais, aplique mais
um estágio na pipeline do desafio anterior que atenda a
seguinte demanda: */
db.movies.aggregate([
  {
    $match: {
      "imdb.rating": { $gte: 7 },
      genres: { $nin: ["Crime", "Horror"] },
      rated: { $in: ["PG", "G"] },
      languages: { $all: ["English", "Spanish"] },
    },
  },
  {
    $project: {
      titulo: "$title",
      avaliado: "$rated",
      notaIMDB: "$imdb.rating",
      votosIMDB: "$imdb.votes",
      ano: "$year",
      _id: 0,
    },
  },
  {
    $sort: {
      ano: -1,
      notaIMDB: -1,
      titulo: 1,
    },
  },
]);

/* 4- .. */
  db.movies.aggregate([
    {
      $addFields: {
        title_split: {
          $split: ["$title", " "],
        },
      },
    },
    {
      $match: {
        title_split: { $size: 1 },
      },
    },
    {
      $sort: { title: 1 },
    },
    {
      $project: {
        title_split: 1, _id: 0,
      },
    },
  ]);

/* 5- ... */
const favoriteActors = [
  "Sandra Bullock",
  "Tom Hanks",
  "Julia Roberts",
  "Kevin Spacey",
  "George Clooney"
];

db.movies.aggregate([
  {
    $match: {
      countries: "USA",
      "tomatoes.viewer.rating": { $gte: 3 },
      cast: { $in: favoriteActors },
    },
  },
  {
    $addFields: {
      num_favs: { $size: { $setIntersection: [favoriteActors, "$cast"] } },
    },
  },
  {
    $sort: {
      num_favs: -1, "tomatoes.viewer.rating": -1, title: -1 
    }
  },
  {
    $project: { title: 1, _id: 0 }
  },
  {
    $skip: 24
  },
  {
    $limit: 1
  },
]);

/* 6-
-selecionar todos os filmes que ganharam oscar pelo menos uma vez, (awards)
-calcular
  maior valor,
  menor valor,
  media,
  desvio padrao das avaliacoes (imdb.rating) ($stdDevSamp)
*/

db.movies.aggregate([
  { $match: { awards: { $regex: /Won\s\d+.Oscars?/ } } },
  {
    $group: {
      _id: null,
      maior_rating: { $max: "$imdb.rating" },
      menor_rating: { $min: "$imdb.rating" },
      media_rating: { $avg: "$imdb.rating" },
      desvio_padrao: { $stdDevSamp: "$imdb.rating" },
    },
  },
  {
    $project: {
      maior_rating: "$maior_rating",
      menor_rating: "$menor_rating",
      media_rating: { $round: ["$media_rating", 1] },
      desvio_padrao: { $round: ["$desvio_padrao", 1] },
      _id: 0,
    },
  },
]);

/* 7-
-Conte quantos filmes cada um dos atores e atrizes do elenco
(cast do banco) ja participaram 
e obtenha uma media do campo imdb.rating para cada um desses
atores e atrizes

-traga o nome do ator e da atriz
-numero de filmes que participou
-media do imdb desses filmes arredondada para uma casa decimal usando $round
considere somente os membros do elenco de filmes com o idioma english
exiba a lista em ordem decrescente de documentos pelo numero de
filmes e nome do ator ou atriz

ESTRATEGIA:
fazer um $group de cast(n)
 */

 db.movies.aggregate([
  {
    $unwind: "$cast",
  },
  {
    $match: { languages: { $in: ["English"] } },
  },
  {
    $group: {
      _id: "$cast",
      count: { $sum: 1 },
      media: { $avg: "$imdb.rating" },
    },
  },
  {
    $project: {
      _id: "$_id",
      numeroFilmes: "$count",
      mediaIMDB: { $round: ["$media", 1] },
    },
  },
  { $sort: { numeroFilmes: -1, _id: -1 } },
]);

/* 8-
  Trocando de contexto, vamos utilizar nossa outra coleção que
  contém dados de empresas aéreas, suas rotas, seus
  voos e parcerias.

  Liste todas as parcerias da coleção air_alliances, que voam rotas
  com um Boing 747 ou um Airbus A380 , para descobrir qual delas
  tem o maior número de rotas com esses aviões.

No campo airplane, na coleção air_routes:
  Boing 747 está abreviado para 747
  Airbus A380 está abreviado para 380

{ "_id" : <nome_da_alianca>, "totalRotas" : <total_de_rotas> }

  ESTRATEGIA:
  Parceria se encontra em alliances.
    -fazer unwind das empresas airlines em alliances
    -pegar o nome empresa na colecao routes que voam com 747 ou 380
    -fazer lookup do nome desta empresa 
  */

  db.air_alliances.aggregate([
    { $unwind: "$airlines" },
    { 
      $lookup: {
        from: "air_routes",
        localField: "airlines",
        foreignField: "airline.name",
        as: "rotas",
      },
    },
    { $unwind: "$rotas" },
    { $match: { "rotas.airplane": { $in: ["747", "380"] } } },
    { $group: { _id: "$name", totalRotas: { $sum: 1 } } },
    { $sort: { totalRotas: -1 } },
    { $limit: 1 },
  ]);

/* 9- A partir da coleção trips, determine o menor e o maior ano
de nascimento.
  -Guarde essa informação, você precisará dela mais tarde.
  -Não considere documentos com valores vazios ("") e em que o campo
    não existe!
  -Para este desafio utilize o operador $toInt para converter
  de string para valor inteiro.

  { "maiorAnoNascimento" : <ano>, "menorAnoNascimento" : <ano> }
 */
db.trips.aggregate([
  {
    $match: { birthYear: { $exists: 1, $ne: "" } },
  },
  {
    $group: {
      _id: null,
      maiorAnoNascimento: { $max: { $toInt: "$birthYear" } },
      menorAnoNascimento: { $min: { $toInt: "$birthYear" } },
    },
  },
  { $project: { _id: 0 } },
]);

/* 10- Encontre a duração média de viagens por tipo de usuário.
  -Exiba o valor em horas com apenas duas casas decimais
  -Exiba a média de viagens ordenada de forma crescente.
  { "tipo" : <tipo>, "duracaoMedia" : <duracaoMedia> }
 */

db.trips.aggregate([
  {
    $project: {
      _id: 0,
      tipo: "$usertype",
      duracao: {
        $divide: [{ $subtract: ["$stopTime", "$startTime"] }, 3600000],
      },
    },
  },
  {
    $group: {
      _id: "$tipo",
      duracaoMedia: { $avg: "$duracao" },
    },
  },
  {
    $project: {
      _id: 0,
      tipo: "$_id",
      duracaoMedia: { $round: ["$duracaoMedia", 2] },
    },
  },
  {
    $sort: { duracaoMedia: 1 },
  },
]);

/* 11- Determine qual o dia da semana com maior número de viagens iniciadas.
-Dica: Utilize o operador $dayOfWeek para extrair o dia da
 semana como um número de uma data.
-{ "diaDaSemana" : <dia_da_semana>, "total" : <total_de_viagens> }
*/

db.trips.aggregate([
  { $group: { _id: { $dayOfWeek: "$startTime" }, count: { $sum: 1 } } },
  { $sort: { count: -1 } },
  { $limit: 1 },
  { $project: { diaDaSemana: "$_id", total: "$count", _id: 0 } },
]);

/* 12- Usando a pipeline anterior que retorna o dia com mais viagens,
determine qual estação tem o maior número de viagens nesse dia da semana.
-Exiba apenas o nome da estação e o total de viagens.
{ "nomeEstacao" : <nome_da_estacao>, "total" : <total_de_viagens> }
ESTRATEGIA:
-selecionar apenas objetos que contem o dia da semana com mais viagem

*/
db.trips.aggregate([
  { $addFields: { weekDay: { $dayOfWeek: "$startTime" } } },
  { $match: { weekDay: 5 } },
  { $group: { _id: "$startStationName", count: { $sum: 1 } } },
  { $sort: { count: -1 } },
  { $limit: 1 },
  { $project: { nomeEstacao: "$_id", total: "$count", _id: 0 } },
]);

 db.trips.find();

